import httpx
from typing import Optional, Dict, Any, List, Union
from config.config import API_TOKEN, API_URL
from datetime import datetime, timedelta
from bot.vpn_logger import vpn_api_logger as logger

class VPNClient:
    def __init__(self, server_url: str, server_name: str = "VPN Server"):
        self.api_token = API_TOKEN
        self.base_url = server_url
        self.server_name = server_name
        
        logger.info(f"üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VPN –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è {server_name}")
        logger.info(f"üåê URL —Å–µ—Ä–≤–µ—Ä–∞: {server_url}")
        logger.info(f"üîë API —Ç–æ–∫–µ–Ω: {'*' * 10}{API_TOKEN[-5:] if API_TOKEN else '–ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù'}")
        
        if not self.base_url:
            logger.error("‚ùå URL —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            raise ValueError(f"URL —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            
        if not self.api_token:
            logger.warning("‚ö†Ô∏è API —Ç–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            
        self.headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json"
        }
        
        logger.info(f"‚úÖ VPN –∫–ª–∏–µ–Ω—Ç –¥–ª—è {server_name} –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    @classmethod
    def from_server(cls, server):
        """–°–æ–∑–¥–∞–µ—Ç VPNClient –∏–∑ –æ–±—ä–µ–∫—Ç–∞ Server"""
        logger.info(f"üèóÔ∏è –°–æ–∑–¥–∞—é VPN –∫–ª–∏–µ–Ω—Ç –∏–∑ –æ–±—ä–µ–∫—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞: {server.name}")
        return cls(server_url=server.url, server_name=server.name)

    @classmethod 
    def from_fallback(cls):
        """–°–æ–∑–¥–∞–µ—Ç VPNClient –∏–∑ fallback –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        logger.info("üèóÔ∏è –°–æ–∑–¥–∞—é VPN –∫–ª–∏–µ–Ω—Ç –∏–∑ fallback –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
        if not API_URL:
            logger.error("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ fallback URL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
            raise ValueError("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ fallback URL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
        return cls(server_url=API_URL, server_name="Fallback Server")

    async def create_vpn_config(
        self, 
        username: str,
        data_limit: int = 0,
        expire_days: int = 30,
        inbounds: Optional[Dict[str, List[str]]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create a new VPN configuration for a user
        
        Args:
            username: Username for the VPN account
            data_limit: Data limit in bytes (0 for unlimited)
            expire_days: Number of days until expiration
            inbounds: Dictionary of inbounds to enable
        """
        logger.info(f"üöÄ –°–æ–∑–¥–∞—é VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {username}")
        logger.info(f"üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: data_limit={data_limit}, expire_days={expire_days}")

        expire_timestamp = int((datetime.now() + timedelta(days=expire_days)).timestamp())
        logger.info(f"‚è∞ Timestamp –∏—Å—Ç–µ—á–µ–Ω–∏—è: {expire_timestamp} ({datetime.fromtimestamp(expire_timestamp)})")
        
        request_data = {
            "username": username,
            "data_limit": data_limit,
            "data_limit_reset_strategy": "no_reset",
            "expire": expire_timestamp,
            "inbounds": {
                "vless": ["VLESS TCP REALITY"]
            },
            "next_plan": {
                "add_remaining_traffic": False,
                "data_limit": 0,
                "expire": 0,
                "fire_on_either": True
            },
            "note": "",
            "on_hold_expire_duration": 0,
            "on_hold_timeout": datetime.now().isoformat(),
            "proxies": {
                "vless": {
                    "id": self._generate_uuid()
                }
            },
            "status": "active"
        }
        
        logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ {self.base_url}/api/user")
        logger.info(f"üìÑ –î–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å–∞: {request_data}")
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.base_url}/api/user",
                    headers=self.headers,
                    json=request_data
                )
                
                logger.info(f"üì° –°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
                logger.info(f"üìã –ó–∞–≥–æ–ª–æ–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞: {dict(response.headers)}")
                
                if response.status_code != 200:
                    logger.error(f"‚ùå HTTP –æ—à–∏–±–∫–∞: {response.status_code}")
                    logger.error(f"üìÑ –¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: {response.text}")
                
                response.raise_for_status()
                response_data = response.json()
                
                logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç API")
                logger.info(f"üì• –î–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç–∞: {response_data}")
                
                return response_data
                
        except httpx.TimeoutException as e:
            logger.error(f"‚è∞ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except httpx.HTTPStatusError as e:
            logger.error(f"üö´ HTTP –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            logger.error(f"üìÑ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞: {e.response.text}")
            return None
        except httpx.RequestError as e:
            logger.error(f"üîå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except Exception as e:
            logger.error(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            logger.exception("–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:")
            return None

    async def get_vpn_config(self, username: str) -> Optional[Dict[str, Any]]:
        """
        Get existing VPN configuration for a user
        """
        logger.info(f"üîç –ü–æ–ª—É—á–∞—é VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {username}")
        logger.info(f"üì§ GET –∑–∞–ø—Ä–æ—Å –Ω–∞ {self.base_url}/api/user/{username}")
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self.base_url}/api/user/{username}",
                    headers=self.headers
                )
                
                logger.info(f"üì° –°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
                
                if response.status_code == 404:
                    logger.warning(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ")
                    return None
                elif response.status_code != 200:
                    logger.error(f"‚ùå HTTP –æ—à–∏–±–∫–∞: {response.status_code}")
                    logger.error(f"üìÑ –¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: {response.text}")
                
                response.raise_for_status()
                response_data = response.json()
                
                logger.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è {username}")
                return response_data
                
        except httpx.TimeoutException as e:
            logger.error(f"‚è∞ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except httpx.HTTPStatusError as e:
            logger.error(f"üö´ HTTP –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except httpx.RequestError as e:
            logger.error(f"üîå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except Exception as e:
            logger.error(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            logger.exception("–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:")
            return None

    def _generate_uuid(self) -> str:
        """Generate a UUID for VMess proxy"""
        import uuid
        generated_uuid = str(uuid.uuid4())
        logger.info(f"üÜî –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω UUID: {generated_uuid}")
        return generated_uuid

    async def update_vpn_config(
        self,
        username: str,
        status: Optional[str] = None,
        expire: Optional[int] = None,
        data_limit: Optional[int] = None,
        data_limit_reset_strategy: Optional[str] = None,
        proxies: Optional[Dict[str, Any]] = None,
        inbounds: Optional[Dict[str, List[str]]] = None,
        note: Optional[str] = None,
        on_hold_timeout: Optional[str] = None,
        on_hold_expire_duration: Optional[int] = None,
        next_plan: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Update an existing VPN user configuration
        
        Args:
            username: Username of the user to update
            status: New status ('active', 'disabled', 'on_hold', 'limited', 'expired')
            expire: UTC timestamp for new expiration (0 for unlimited)
            data_limit: New data limit in bytes (0 for unlimited)
            data_limit_reset_strategy: New reset strategy ('daily', 'weekly', 'monthly', 'no_reset')
            proxies: New protocol settings
            inbounds: New protocol tags for inbound connections
            note: New note text
            on_hold_timeout: UTC timestamp for on_hold status
            on_hold_expire_duration: Duration in seconds for on_hold status
            next_plan: Next user plan settings
        """
        logger.info(f"üîÑ –û–±–Ω–æ–≤–ª—è—é VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {username}")
        logger.info(f"üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: status={status}, expire={expire}")
        if expire:
            logger.info(f"‚è∞ –ù–æ–≤–æ–µ –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è: {datetime.fromtimestamp(expire)}")
        
        update_data = {}
        
        if status is not None:
            update_data["status"] = status
        if expire is not None:
            update_data["expire"] = expire
        if data_limit is not None:
            update_data["data_limit"] = data_limit
        if data_limit_reset_strategy is not None:
            update_data["data_limit_reset_strategy"] = data_limit_reset_strategy
        if proxies is not None:
            update_data["proxies"] = proxies
        if inbounds is not None:
            update_data["inbounds"] = inbounds
        if note is not None:
            update_data["note"] = note
        if on_hold_timeout is not None:
            update_data["on_hold_timeout"] = on_hold_timeout
        if on_hold_expire_duration is not None:
            update_data["on_hold_expire_duration"] = on_hold_expire_duration
        if next_plan is not None:
            update_data["next_plan"] = next_plan

        logger.info(f"üì§ PUT –∑–∞–ø—Ä–æ—Å –Ω–∞ {self.base_url}/api/user/{username}")
        logger.info(f"üìÑ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {update_data}")

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.put(
                    f"{self.base_url}/api/user/{username}",
                    headers=self.headers,
                    json=update_data
                )
                
                logger.info(f"üì° –°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
                
                if response.status_code == 404:
                    logger.warning(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ")
                    return None
                elif response.status_code != 200:
                    logger.error(f"‚ùå HTTP –æ—à–∏–±–∫–∞: {response.status_code}")
                    logger.error(f"üìÑ –¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: {response.text}")
                
                response.raise_for_status()
                response_data = response.json()
                
                logger.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {username}")
                logger.info(f"üì• –î–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç–∞: {response_data}")
                
                return response_data
                
        except httpx.TimeoutException as e:
            logger.error(f"‚è∞ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except httpx.HTTPStatusError as e:
            logger.error(f"üö´ HTTP –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            logger.error(f"üìÑ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞: {e.response.text}")
            return None
        except httpx.RequestError as e:
            logger.error(f"üîå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return None
        except Exception as e:
            logger.error(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ VPN –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            logger.exception("–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:")
            return None

    # async def activate_user(self, username: str) -> Optional[Dict[str, Any]]:
    #     """
    #     Convenience method to activate a user
    #     """
    #     return await self.update_vpn_config(
    #         username=username,
    #         status="active",
    #         expire=30
    #     )

    async def delete_user(self, username: str):
        try:
            async with httpx.AsyncClient() as client:
                response = await client.delete(
                    url=f"{self.base_url}/api/user/{username}",
                    headers=self.headers,
                )
                response.raise_for_status()
                return response.status_code
        except httpx.HTTPError as e:
            print(f"Error deleting VPN config: {e}")
            return None
